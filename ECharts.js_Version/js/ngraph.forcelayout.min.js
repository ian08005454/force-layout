/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = createLayout;\nmodule.exports.simulator = __webpack_require__(/*! ./lib/createPhysicsSimulator */ \"./lib/createPhysicsSimulator.js\");\n\nvar eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n\n/**\n * Creates force based layout for a given graph.\n *\n * @param {ngraph.graph} graph which needs to be laid out\n * @param {object} physicsSettings if you need custom settings\n * for physics simulator you can pass your own settings here. If it's not passed\n * a default one will be created.\n */\nfunction createLayout(graph, physicsSettings) {\n  if (!graph) {\n    throw new Error('Graph structure cannot be undefined');\n  }\n\n  var createSimulator = (physicsSettings && physicsSettings.createSimulator) || __webpack_require__(/*! ./lib/createPhysicsSimulator */ \"./lib/createPhysicsSimulator.js\");\n  var physicsSimulator = createSimulator(physicsSettings);\n  if (Array.isArray(physicsSettings)) throw new Error('Physics settings is expected to be an object');\n\n  var nodeMass = defaultNodeMass;\n  if (physicsSettings && typeof physicsSettings.nodeMass === 'function') {\n    nodeMass = physicsSettings.nodeMass;\n  }\n\n  var nodeBodies = new Map();\n  var springs = {};\n  var bodiesCount = 0;\n\n  var springTransform = physicsSimulator.settings.springTransform || noop;\n\n  // Initialize physics with what we have in the graph:\n  initPhysics();\n  listenToEvents();\n\n  var wasStable = false;\n\n  var api = {\n    /**\n     * Performs one step of iterative layout algorithm\n     *\n     * @returns {boolean} true if the system should be considered stable; False otherwise.\n     * The system is stable if no further call to `step()` can improve the layout.\n     */\n    step: function() {\n      if (bodiesCount === 0) {\n        updateStableStatus(true);\n        return true;\n      }\n\n      var lastMove = physicsSimulator.step();\n\n      // Save the movement in case if someone wants to query it in the step\n      // callback.\n      api.lastMove = lastMove;\n\n      // Allow listeners to perform low-level actions after nodes are updated.\n      api.fire('step');\n\n      var ratio = lastMove/bodiesCount;\n      var isStableNow = ratio <= 0.01; // TODO: The number is somewhat arbitrary...\n      updateStableStatus(isStableNow);\n\n\n      return isStableNow;\n    },\n\n    /**\n     * For a given `nodeId` returns position\n     */\n    getNodePosition: function (nodeId) {\n      return getInitializedBody(nodeId).pos;\n    },\n\n    /**\n     * Sets position of a node to a given coordinates\n     * @param {string} nodeId node identifier\n     * @param {number} x position of a node\n     * @param {number} y position of a node\n     * @param {number=} z position of node (only if applicable to body)\n     */\n    setNodePosition: function (nodeId) {\n      var body = getInitializedBody(nodeId);\n      body.setPosition.apply(body, Array.prototype.slice.call(arguments, 1));\n    },\n\n    /**\n     * @returns {Object} Link position by link id\n     * @returns {Object.from} {x, y} coordinates of link start\n     * @returns {Object.to} {x, y} coordinates of link end\n     */\n    getLinkPosition: function (linkId) {\n      var spring = springs[linkId];\n      if (spring) {\n        return {\n          from: spring.from.pos,\n          to: spring.to.pos\n        };\n      }\n    },\n\n    /**\n     * @returns {Object} area required to fit in the graph. Object contains\n     * `x1`, `y1` - top left coordinates\n     * `x2`, `y2` - bottom right coordinates\n     */\n    getGraphRect: function () {\n      return physicsSimulator.getBBox();\n    },\n\n    /**\n     * Iterates over each body in the layout simulator and performs a callback(body, nodeId)\n     */\n    forEachBody: forEachBody,\n\n    /*\n     * Requests layout algorithm to pin/unpin node to its current position\n     * Pinned nodes should not be affected by layout algorithm and always\n     * remain at their position\n     */\n    pinNode: function (node, isPinned) {\n      var body = getInitializedBody(node.id);\n       body.isPinned = !!isPinned;\n    },\n\n    /**\n     * Checks whether given graph's node is currently pinned\n     */\n    isNodePinned: function (node) {\n      return getInitializedBody(node.id).isPinned;\n    },\n\n    /**\n     * Request to release all resources\n     */\n    dispose: function() {\n      graph.off('changed', onGraphChanged);\n      api.fire('disposed');\n    },\n\n    /**\n     * Gets physical body for a given node id. If node is not found undefined\n     * value is returned.\n     */\n    getBody: getBody,\n\n    /**\n     * Gets spring for a given edge.\n     *\n     * @param {string} linkId link identifer. If two arguments are passed then\n     * this argument is treated as formNodeId\n     * @param {string=} toId when defined this parameter denotes head of the link\n     * and first argument is treated as tail of the link (fromId)\n     */\n    getSpring: getSpring,\n\n    /**\n     * Returns length of cumulative force vector. The closer this to zero - the more stable the system is\n     */\n    getForceVectorLength: getForceVectorLength,\n\n    /**\n     * [Read only] Gets current physics simulator\n     */\n    simulator: physicsSimulator,\n\n    /**\n     * Gets the graph that was used for layout\n     */\n    graph: graph,\n\n    /**\n     * Gets amount of movement performed during last step operation\n     */\n    lastMove: 0\n  };\n\n  eventify(api);\n\n  return api;\n\n  function updateStableStatus(isStableNow) {\n    if (wasStable !== isStableNow) {\n      wasStable = isStableNow;\n      onStableChanged(isStableNow);\n    }\n  }\n\n  function forEachBody(cb) {\n    nodeBodies.forEach(cb);\n  }\n\n  function getForceVectorLength() {\n    var fx = 0, fy = 0;\n    forEachBody(function(body) {\n      fx += Math.abs(body.force.x);\n      fy += Math.abs(body.force.y);\n    });\n    return Math.sqrt(fx * fx + fy * fy);\n  }\n\n  function getSpring(fromId, toId) {\n    var linkId;\n    if (toId === undefined) {\n      if (typeof fromId !== 'object') {\n        // assume fromId as a linkId:\n        linkId = fromId;\n      } else {\n        // assume fromId to be a link object:\n        linkId = fromId.id;\n      }\n    } else {\n      // toId is defined, should grab link:\n      var link = graph.hasLink(fromId, toId);\n      if (!link) return;\n      linkId = link.id;\n    }\n\n    return springs[linkId];\n  }\n\n  function getBody(nodeId) {\n    return nodeBodies.get(nodeId);\n  }\n\n  function listenToEvents() {\n    graph.on('changed', onGraphChanged);\n  }\n\n  function onStableChanged(isStable) {\n    api.fire('stable', isStable);\n  }\n\n  function onGraphChanged(changes) {\n    for (var i = 0; i < changes.length; ++i) {\n      var change = changes[i];\n      if (change.changeType === 'add') {\n        if (change.node) {\n          initBody(change.node.id);\n        }\n        if (change.link) {\n          initLink(change.link);\n        }\n      } else if (change.changeType === 'remove') {\n        if (change.node) {\n          releaseNode(change.node);\n        }\n        if (change.link) {\n          releaseLink(change.link);\n        }\n      }\n    }\n    bodiesCount = graph.getNodesCount();\n  }\n\n  function initPhysics() {\n    bodiesCount = 0;\n\n    graph.forEachNode(function (node) {\n      initBody(node.id);\n      bodiesCount += 1;\n    });\n\n    graph.forEachLink(initLink);\n  }\n\n  function initBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    if (!body) {\n      var node = graph.getNode(nodeId);\n      if (!node) {\n        throw new Error('initBody() was called with unknown node id');\n      }\n\n      var pos = node.position;\n      if (!pos) {\n        var neighbors = getNeighborBodies(node);\n        pos = physicsSimulator.getBestNewBodyPosition(neighbors);\n      }\n\n      body = physicsSimulator.addBodyAt(pos);\n      body.id = nodeId;\n\n      nodeBodies.set(nodeId, body);\n      updateBodyMass(nodeId);\n\n      if (isNodeOriginallyPinned(node)) {\n        body.isPinned = true;\n      }\n    }\n  }\n\n  function releaseNode(node) {\n    var nodeId = node.id;\n    var body = nodeBodies.get(nodeId);\n    if (body) {\n      nodeBodies.delete(nodeId);\n      physicsSimulator.removeBody(body);\n    }\n  }\n\n  function initLink(link) {\n    updateBodyMass(link.fromId);\n    updateBodyMass(link.toId);\n\n    var fromBody = nodeBodies.get(link.fromId),\n        toBody  = nodeBodies.get(link.toId),\n        spring = physicsSimulator.addSpring(fromBody, toBody, link.length);\n\n    springTransform(link, spring);\n\n    springs[link.id] = spring;\n  }\n\n  function releaseLink(link) {\n    var spring = springs[link.id];\n    if (spring) {\n      var from = graph.getNode(link.fromId),\n          to = graph.getNode(link.toId);\n\n      if (from) updateBodyMass(from.id);\n      if (to) updateBodyMass(to.id);\n\n      delete springs[link.id];\n\n      physicsSimulator.removeSpring(spring);\n    }\n  }\n\n  function getNeighborBodies(node) {\n    // TODO: Could probably be done better on memory\n    var neighbors = [];\n    if (!node.links) {\n      return neighbors;\n    }\n    var maxNeighbors = Math.min(node.links.length, 2);\n    for (var i = 0; i < maxNeighbors; ++i) {\n      var link = node.links[i];\n      var otherBody = link.fromId !== node.id ? nodeBodies.get(link.fromId) : nodeBodies.get(link.toId);\n      if (otherBody && otherBody.pos) {\n        neighbors.push(otherBody);\n      }\n    }\n\n    return neighbors;\n  }\n\n  function updateBodyMass(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    body.mass = nodeMass(nodeId);\n    if (Number.isNaN(body.mass)) {\n      throw new Error('Node mass should be a number');\n    }\n  }\n\n  /**\n   * Checks whether graph node has in its settings pinned attribute,\n   * which means layout algorithm cannot move it. Node can be marked\n   * as pinned, if it has \"isPinned\" attribute, or when node.data has it.\n   *\n   * @param {Object} node a graph node to check\n   * @return {Boolean} true if node should be treated as pinned; false otherwise.\n   */\n  function isNodeOriginallyPinned(node) {\n    return (node && (node.isPinned || (node.data && node.data.isPinned)));\n  }\n\n  function getInitializedBody(nodeId) {\n    var body = nodeBodies.get(nodeId);\n    if (!body) {\n      initBody(nodeId);\n      body = nodeBodies.get(nodeId);\n    }\n    return body;\n  }\n\n  /**\n   * Calculates mass of a body, which corresponds to node with given id.\n   *\n   * @param {String|Number} nodeId identifier of a node, for which body mass needs to be calculated\n   * @returns {Number} recommended mass of the body;\n   */\n  function defaultNodeMass(nodeId) {\n    var links = graph.getLinks(nodeId);\n    if (!links) return 1;\n    return 1 + links.length / 3.0;\n  }\n}\n\nfunction noop() { }\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./index.js?");

/***/ }),

/***/ "./lib/codeGenerators/createPatternBuilder.js":
/*!****************************************************!*\
  !*** ./lib/codeGenerators/createPatternBuilder.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const getVariableName = __webpack_require__(/*! ./getVariableName */ \"./lib/codeGenerators/getVariableName.js\");\n\nmodule.exports = function createPatternBuilder(dimension) {\n\n  return pattern;\n  \n  function pattern(template, config) {\n    let indent = (config && config.indent) || 0;\n    let join = (config && config.join !== undefined) ? config.join : '\\n';\n    let indentString = Array(indent + 1).join(' ');\n    let buffer = [];\n    for (let i = 0; i < dimension; ++i) {\n      let variableName = getVariableName(i);\n      let prefix = (i === 0) ? '' : indentString;\n      buffer.push(prefix + template.replace(/{var}/g, variableName));\n    }\n    return buffer.join(join);\n  }\n};\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/createPatternBuilder.js?");

/***/ }),

/***/ "./lib/codeGenerators/generateBounds.js":
/*!**********************************************!*\
  !*** ./lib/codeGenerators/generateBounds.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = generateBoundsFunction;\nmodule.exports.generateFunctionBody = generateBoundsFunctionBody;\n\nconst createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"./lib/codeGenerators/createPatternBuilder.js\");\n\nfunction generateBoundsFunction(dimension) {\n  let code = generateBoundsFunctionBody(dimension);\n  return new Function('bodies', 'settings', 'random', code);\n}\n\nfunction generateBoundsFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n\n  let code = `\n  var boundingBox = {\n    ${pattern('min_{var}: 0, max_{var}: 0,', {indent: 4})}\n  };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset: resetBoundingBox,\n\n    getBestNewPosition: function (neighbors) {\n      var ${pattern('base_{var} = 0', {join: ', '})};\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          let neighborPos = neighbors[i].pos;\n          ${pattern('base_{var} += neighborPos.{var};', {indent: 10})}\n        }\n\n        ${pattern('base_{var} /= neighbors.length;', {indent: 8})}\n      } else {\n        ${pattern('base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;', {indent: 8})}\n      }\n\n      var springLength = settings.springLength;\n      return {\n        ${pattern('{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,', {indent: 8})}\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) return; // No bodies - no borders.\n\n    ${pattern('var max_{var} = Number.MIN_VALUE;', {indent: 4})}\n    ${pattern('var min_{var} = Number.MAX_VALUE;', {indent: 4})}\n\n    while(i--) {\n      // this is O(n), it could be done faster with quadtree, if we check the root node bounds\n      var bodyPos = bodies[i].pos;\n      ${pattern('if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};', {indent: 6})}\n      ${pattern('if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};', {indent: 6})}\n    }\n\n    ${pattern('boundingBox.min_{var} = min_{var};', {indent: 4})}\n    ${pattern('boundingBox.max_{var} = max_{var};', {indent: 4})}\n  }\n\n  function resetBoundingBox() {\n    ${pattern('boundingBox.min_{var} = boundingBox.max_{var} = 0;', {indent: 4})}\n  }\n`;\n  return code;\n}\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/generateBounds.js?");

/***/ }),

/***/ "./lib/codeGenerators/generateCreateBody.js":
/*!**************************************************!*\
  !*** ./lib/codeGenerators/generateCreateBody.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"./lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateCreateBodyFunction;\nmodule.exports.generateCreateBodyFunctionBody = generateCreateBodyFunctionBody;\n\nfunction generateCreateBodyFunction(dimension, debugSetters) {\n  let code = generateCreateBodyFunctionBody(dimension, debugSetters);\n  let {Body} = (new Function(code))();\n  return Body;\n}\n\nfunction generateCreateBodyFunctionBody(dimension, debugSetters) {\n  let pattern = createPatternBuilder(dimension);\n  let variableList = pattern('{var}', {join: ', '});\n  let setters = '';\n  if (debugSetters) {\n    setters = `${pattern(\"\\n\\\n   var v{var};\\n\\\nObject.defineProperty(this, '{var}', {\\n\\\n  set: function(v) { \\n\\\n    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');\\n\\\n    v{var} = v; \\n\\\n  },\\n\\\n  get: function() { return v{var}; }\\n\\\n});\")}`;\n  }\n\n  let code = `\nfunction Vector(${variableList}) {\n${setters}\n  if (typeof arguments[0] === 'object') {\n    // could be another vector\n    let v = arguments[0];\n    ${pattern('if (!Number.isFinite(v.{var})) throw new Error(\"Expected value is not a finite number at Vector constructor ({var})\");', {indent: 4})}\n    ${pattern('this.{var} = v.{var};', {indent: 4})}\n  } else {\n    ${pattern('this.{var} = typeof {var} === \"number\" ? {var} : 0;', {indent: 4})}\n  }\n}\n\nVector.prototype.reset = function () {\n  ${pattern('this.{var} = ', {join: ''})}0;\n};\n\nfunction Body(${variableList}) {\n  this.isPinned = false;\n  this.pos = new Vector(${variableList});\n  this.force = new Vector();\n  this.velocity = new Vector();\n  this.mass = 1;\n\n  this.springCount = 0;\n  this.springLength = 0;\n}\n\nBody.prototype.reset = function() {\n  this.force.reset();\n  this.springCount = 0;\n  this.springLength = 0;\n}\n\nBody.prototype.setPosition = function (${variableList}) {\n  ${pattern('this.pos.{var} = {var} || 0;', {indent: 2})}\n};\n\nreturn {Body: Body, Vector: Vector};\n`;\n  return code;\n}\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/generateCreateBody.js?");

/***/ }),

/***/ "./lib/codeGenerators/generateCreateDragForce.js":
/*!*******************************************************!*\
  !*** ./lib/codeGenerators/generateCreateDragForce.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"./lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateCreateDragForceFunction;\nmodule.exports.generateCreateDragForceFunctionBody = generateCreateDragForceFunctionBody;\n\nfunction generateCreateDragForceFunction(dimension) {\n  let code = generateCreateDragForceFunctionBody(dimension);\n  return new Function('options', code);\n}\n\nfunction generateCreateDragForceFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');\n\n  return {\n    update: function(body) {\n      ${pattern('body.force.{var} -= options.dragCoefficient * body.velocity.{var};', {indent: 6})}\n    }\n  };\n`;\n  return code;\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/generateCreateDragForce.js?");

/***/ }),

/***/ "./lib/codeGenerators/generateCreateSpringForce.js":
/*!*********************************************************!*\
  !*** ./lib/codeGenerators/generateCreateSpringForce.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"./lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateCreateSpringForceFunction;\nmodule.exports.generateCreateSpringForceFunctionBody = generateCreateSpringForceFunctionBody;\n\nfunction generateCreateSpringForceFunction(dimension) {\n  let code = generateCreateSpringForceFunctionBody(dimension);\n  return new Function('options', 'random', code);\n}\n\nfunction generateCreateSpringForceFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');\n  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');\n\n  return {\n    /**\n     * Updates forces acting on a spring\n     */\n    update: function (spring) {\n      var body1 = spring.from;\n      var body2 = spring.to;\n      var length = spring.length < 0 ? options.springLength : spring.length;\n      ${pattern('var d{var} = body2.pos.{var} - body1.pos.{var};', {indent: 6})}\n      var r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n\n      if (r === 0) {\n        ${pattern('d{var} = (random.nextDouble() - 0.5) / 50;', {indent: 8})}\n        r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n      }\n\n      var d = r - length;\n      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;\n\n      ${pattern('body1.force.{var} += coefficient * d{var}', {indent: 6})};\n      body1.springCount += 1;\n      body1.springLength += r;\n\n      ${pattern('body2.force.{var} -= coefficient * d{var}', {indent: 6})};\n      body2.springCount += 1;\n      body2.springLength += r;\n    }\n  };\n`;\n  return code;\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/generateCreateSpringForce.js?");

/***/ }),

/***/ "./lib/codeGenerators/generateIntegrator.js":
/*!**************************************************!*\
  !*** ./lib/codeGenerators/generateIntegrator.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"./lib/codeGenerators/createPatternBuilder.js\");\n\nmodule.exports = generateIntegratorFunction;\nmodule.exports.generateIntegratorFunctionBody = generateIntegratorFunctionBody;\n\nfunction generateIntegratorFunction(dimension) {\n  let code = generateIntegratorFunctionBody(dimension);\n  return new Function('bodies', 'timeStep', 'adaptiveTimeStepWeight', code);\n}\n\nfunction generateIntegratorFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let code = `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${pattern('var d{var} = 0, t{var} = 0;', {indent: 2})}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${pattern('body.velocity.{var} += coeff * body.force.{var};', {indent: 4})}\n    ${pattern('var v{var} = body.velocity.{var};', {indent: 4})}\n    var v = Math.sqrt(${pattern('v{var} * v{var}', {join: ' + '})});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${pattern('body.velocity.{var} = v{var} / v;', {indent: 6})}\n    }\n\n    ${pattern('d{var} = timeStep * body.velocity.{var};', {indent: 4})}\n\n    ${pattern('body.pos.{var} += d{var};', {indent: 4})}\n\n    ${pattern('t{var} += Math.abs(d{var});', {indent: 4})}\n  }\n\n  return (${pattern('t{var} * t{var}', {join: ' + '})})/length;\n`;\n  return code;\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/generateIntegrator.js?");

/***/ }),

/***/ "./lib/codeGenerators/generateQuadTree.js":
/*!************************************************!*\
  !*** ./lib/codeGenerators/generateQuadTree.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPatternBuilder = __webpack_require__(/*! ./createPatternBuilder */ \"./lib/codeGenerators/createPatternBuilder.js\");\nconst getVariableName = __webpack_require__(/*! ./getVariableName */ \"./lib/codeGenerators/getVariableName.js\");\n\nmodule.exports = generateQuadTreeFunction;\nmodule.exports.generateQuadTreeFunctionBody = generateQuadTreeFunctionBody;\n\nfunction generateQuadTreeFunction(dimension) {\n  let code = generateQuadTreeFunctionBody(dimension);\n  return (new Function(code))();\n}\n\nfunction generateQuadTreeFunctionBody(dimension) {\n  let pattern = createPatternBuilder(dimension);\n  let quadCount = Math.pow(2, dimension);\n\n  let code = `\n${getInsertStackCode()}\n${getQuadNodeCode()}\n\nfunction createQuadTree(options, random) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  var gravity = options.gravity;\n  var updateQueue = [];\n  var insertStack = new InsertStack();\n  var theta = options.theta;\n\n  var nodesCache = [];\n  var currentInCache = 0;\n  var root = newNode();\n\n  return {\n    insertBodies: insertBodies,\n\n    /**\n     * Gets root node if it is present\n     */\n    getRoot: function() {\n      return root;\n    },\n\n    updateBodyForce: update,\n\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n${assignQuads('      node.')}\n      node.body = null;\n      node.mass = ${pattern('node.mass_{var} = ', {join: ''})}0;\n      ${pattern('node.min_{var} = node.max_{var} = ', {join: ''})}0;\n    } else {\n      node = new QuadNode();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue;\n    var v;\n    ${pattern('var d{var};', {indent: 4})}\n    var r; \n    ${pattern('var f{var} = 0;', {indent: 4})}\n    var queueLength = 1;\n    var shiftIdx = 0;\n    var pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx];\n      var body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        ${pattern('d{var} = body.pos.{var} - sourceBody.pos.{var};', {indent: 8})}\n        r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          ${pattern('d{var} = (random.nextDouble() - 0.5) / 50;', {indent: 10})}\n          r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n        }\n\n        // This is standard gravitation force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        ${pattern('f{var} += v * d{var};', {indent: 8})}\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        ${pattern('d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};', {indent: 8})}\n        r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n\n        if (r === 0) {\n          // Sorry about code duplication. I don't want to create many functions\n          // right away. Just want to see performance first.\n          ${pattern('d{var} = (random.nextDouble() - 0.5) / 50;', {indent: 10})}\n          r = Math.sqrt(${pattern('d{var} * d{var}', {join: ' + '})});\n        }\n        // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.max_${getVariableName(0)} - node.min_${getVariableName(0)}) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was made into square during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          ${pattern('f{var} += v * d{var};', {indent: 10})}\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n${runRecursiveOnChildren()}\n        }\n      }\n    }\n\n    ${pattern('sourceBody.force.{var} += f{var};', {indent: 4})}\n  }\n\n  function insertBodies(bodies) {\n    ${pattern('var {var}min = Number.MAX_VALUE;', {indent: 4})}\n    ${pattern('var {var}max = Number.MIN_VALUE;', {indent: 4})}\n    var i = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    while (i--) {\n      var pos = bodies[i].pos;\n      ${pattern('if (pos.{var} < {var}min) {var}min = pos.{var};', {indent: 6})}\n      ${pattern('if (pos.{var} > {var}max) {var}max = pos.{var};', {indent: 6})}\n    }\n\n    // Makes the bounds square.\n    var maxSideLength = -Infinity;\n    ${pattern('if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;', {indent: 4})}\n\n    currentInCache = 0;\n    root = newNode();\n    ${pattern('root.min_{var} = {var}min;', {indent: 4})}\n    ${pattern('root.max_{var} = {var}min + maxSideLength;', {indent: 4})}\n\n    i = bodies.length - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop();\n      var node = stackItem.node;\n      var body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        ${pattern('var {var} = body.pos.{var};', {indent: 8})}\n        node.mass += body.mass;\n        ${pattern('node.mass_{var} += body.mass * {var};', {indent: 8})}\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0; // Assume we are in the 0's quad.\n        ${pattern('var min_{var} = node.min_{var};', {indent: 8})}\n        ${pattern('var max_{var} = (min_{var} + node.max_{var}) / 2;', {indent: 8})}\n\n${assignInsertionQuadIndex(8)}\n\n        var child = getChild(node, quadIdx);\n\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          ${pattern('child.min_{var} = min_{var};', {indent: 10})}\n          ${pattern('child.max_{var} = max_{var};', {indent: 10})}\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            ${pattern('var d{var} = (node.max_{var} - node.min_{var}) * offset;', {indent: 12})}\n\n            ${pattern('oldBody.pos.{var} = node.min_{var} + d{var};', {indent: 12})}\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n}\n\nfunction getChild(node, idx) {\n${getChildBody()}\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n${setChildBody()}\n}\n\nfunction isSamePosition(point1, point2) {\n  ${pattern('var d{var} = Math.abs(point1.{var} - point2.{var});', {indent: 2})}\n\n  return ${pattern('d{var} < 1e-8', {join: ' && '})};\n}\n\nreturn createQuadTree;\n\n`;\n  return code;\n\n  function getChildBody() {\n    let childBody = [];\n    for (let i = 0; i < quadCount; ++i) {\n      childBody.push(`  if (idx === ${i}) return node.quad${i};`);\n    }\n\n    return childBody.join('\\n');\n    // if (idx === 0) return node.quad0;\n    // if (idx === 1) return node.quad1;\n    // if (idx === 2) return node.quad2;\n    // if (idx === 3) return node.quad3;\n  }\n\n  function setChildBody() {\n    let childBody = [];\n    for (let i = 0; i < quadCount; ++i) {\n      let prefix = (i === 0) ? '  ' : '  else ';\n      childBody.push(`${prefix}if (idx === ${i}) node.quad${i} = child;`);\n    }\n\n    return childBody.join('\\n');\n    // if (idx === 0) node.quad0 = child;\n    // else if (idx === 1) node.quad1 = child;\n    // else if (idx === 2) node.quad2 = child;\n    // else if (idx === 3) node.quad3 = child;\n  }\n\n  function assignInsertionQuadIndex(indentCount) {\n    let insertionCode = [];\n    let indent = Array(indentCount + 1).join(' ');\n    for (let i = 0; i < dimension; ++i) {\n      insertionCode.push(indent + `if (${getVariableName(i)} > max_${getVariableName(i)}) {`);\n      insertionCode.push(indent + `  quadIdx = quadIdx + ${Math.pow(2, i)};`);\n      insertionCode.push(indent + `  min_${getVariableName(i)} = max_${getVariableName(i)};`);\n      insertionCode.push(indent + `  max_${getVariableName(i)} = node.max_${getVariableName(i)};`);\n      insertionCode.push(indent + `}`);\n    }\n    return insertionCode.join('\\n');\n    // if (x > max_x) { // somewhere in the eastern part.\n    //   quadIdx = quadIdx + 1;\n    //   left = right;\n    //   right = node.right;\n    // }\n  }\n\n  function runRecursiveOnChildren() {\n    let indent = Array(11).join(' ');\n    let recursiveCode = [];\n    for (let i = 0; i < quadCount; ++i) {\n      recursiveCode.push(indent + `if (node.quad${i}) {`);\n      recursiveCode.push(indent + `  queue[pushIdx] = node.quad${i};`);\n      recursiveCode.push(indent + `  queueLength += 1;`);\n      recursiveCode.push(indent + `  pushIdx += 1;`);\n      recursiveCode.push(indent + `}`);\n    }\n    return recursiveCode.join('\\n');\n    // if (node.quad0) {\n    //   queue[pushIdx] = node.quad0;\n    //   queueLength += 1;\n    //   pushIdx += 1;\n    // }\n  }\n\n\n  function getQuadNodeCode() {\n    let quadNodeCode = `\nfunction QuadNode() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain bodies:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n${assignQuads('  this.')}\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  ${pattern('this.mass_{var} = 0;', {indent: 2})}\n\n  // bounding box coordinates\n  ${pattern('this.min_{var} = 0;', {indent: 2})}\n  ${pattern('this.max_{var} = 0;', {indent: 2})}\n}\n`;\n    return quadNodeCode;\n  }\n\n  function assignQuads(indent) {\n    // this.quad0 = null;\n    // this.quad1 = null;\n    // this.quad2 = null;\n    // this.quad3 = null;\n    let quads = [];\n    for (let i = 0; i < quadCount; ++i) {\n      quads.push(`${indent}quad${i} = null;`);\n    }\n    return quads.join('\\n');\n  }\n}\n\n\nfunction getInsertStackCode() {\n  return `\n/**\n * Our implementation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        var item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressure: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n`;\n}\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/generateQuadTree.js?");

/***/ }),

/***/ "./lib/codeGenerators/getVariableName.js":
/*!***********************************************!*\
  !*** ./lib/codeGenerators/getVariableName.js ***!
  \***********************************************/
/***/ ((module) => {

eval("module.exports = function getVariableName(index) {\n//  return 'x' + index;\n  if (index === 0) return 'x';\n  if (index === 1) return 'y';\n  if (index === 2) return 'z';\n  return 'c' + (index + 1);\n};\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/codeGenerators/getVariableName.js?");

/***/ }),

/***/ "./lib/createPhysicsSimulator.js":
/*!***************************************!*\
  !*** ./lib/createPhysicsSimulator.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Manages a simulation of physical forces acting on bodies and springs.\n */\nmodule.exports = createPhysicsSimulator;\n\nvar generateCreateBodyFunction = __webpack_require__(/*! ./codeGenerators/generateCreateBody */ \"./lib/codeGenerators/generateCreateBody.js\");\nvar generateQuadTreeFunction = __webpack_require__(/*! ./codeGenerators/generateQuadTree */ \"./lib/codeGenerators/generateQuadTree.js\");\nvar generateBoundsFunction = __webpack_require__(/*! ./codeGenerators/generateBounds */ \"./lib/codeGenerators/generateBounds.js\");\nvar generateCreateDragForceFunction = __webpack_require__(/*! ./codeGenerators/generateCreateDragForce */ \"./lib/codeGenerators/generateCreateDragForce.js\");\nvar generateCreateSpringForceFunction = __webpack_require__(/*! ./codeGenerators/generateCreateSpringForce */ \"./lib/codeGenerators/generateCreateSpringForce.js\");\nvar generateIntegratorFunction = __webpack_require__(/*! ./codeGenerators/generateIntegrator */ \"./lib/codeGenerators/generateIntegrator.js\");\n\nvar dimensionalCache = {};\n\nfunction createPhysicsSimulator(settings) {\n  var Spring = __webpack_require__(/*! ./spring */ \"./lib/spring.js\");\n  var merge = __webpack_require__(/*! ngraph.merge */ \"./node_modules/ngraph.merge/index.js\");\n  var eventify = __webpack_require__(/*! ngraph.events */ \"./node_modules/ngraph.events/index.js\");\n  if (settings) {\n    // Check for names from older versions of the layout\n    if (settings.springCoeff !== undefined) throw new Error('springCoeff was renamed to springCoefficient');\n    if (settings.dragCoeff !== undefined) throw new Error('dragCoeff was renamed to dragCoefficient');\n  }\n\n  settings = merge(settings, {\n      /**\n       * Ideal length for links (springs in physical model).\n       */\n      springLength: 10,\n\n      /**\n       * Hook's law coefficient. 1 - solid spring.\n       */\n      springCoefficient: 0.8, \n\n      /**\n       * Coulomb's law coefficient. It's used to repel nodes thus should be negative\n       * if you make it positive nodes start attract each other :).\n       */\n      gravity: -12,\n\n      /**\n       * Theta coefficient from Barnes Hut simulation. Ranged between (0, 1).\n       * The closer it's to 1 the more nodes algorithm will have to go through.\n       * Setting it to one makes Barnes Hut simulation no different from\n       * brute-force forces calculation (each node is considered).\n       */\n      theta: 0.8,\n\n      /**\n       * Drag force coefficient. Used to slow down system, thus should be less than 1.\n       * The closer it is to 0 the less tight system will be.\n       */\n      dragCoefficient: 0.9, // TODO: Need to rename this to something better. E.g. `dragCoefficient`\n\n      /**\n       * Default time step (dt) for forces integration\n       */\n      timeStep : 0.5,\n\n      /**\n       * Adaptive time step uses average spring length to compute actual time step:\n       * See: https://twitter.com/anvaka/status/1293067160755957760\n       */\n      adaptiveTimeStepWeight: 0,\n\n      /**\n       * This parameter defines number of dimensions of the space where simulation\n       * is performed. \n       */\n      dimensions: 2,\n\n      /**\n       * In debug mode more checks are performed, this will help you catch errors\n       * quickly, however for production build it is recommended to turn off this flag\n       * to speed up computation.\n       */\n      debug: false\n  });\n\n  var factory = dimensionalCache[settings.dimensions];\n  if (!factory) {\n    var dimensions = settings.dimensions;\n    factory = {\n      Body: generateCreateBodyFunction(dimensions, settings.debug),\n      createQuadTree: generateQuadTreeFunction(dimensions),\n      createBounds: generateBoundsFunction(dimensions),\n      createDragForce: generateCreateDragForceFunction(dimensions),\n      createSpringForce: generateCreateSpringForceFunction(dimensions),\n      integrate: generateIntegratorFunction(dimensions),\n    };\n    dimensionalCache[dimensions] = factory;\n  }\n\n  var Body = factory.Body;\n  var createQuadTree = factory.createQuadTree;\n  var createBounds = factory.createBounds;\n  var createDragForce = factory.createDragForce;\n  var createSpringForce = factory.createSpringForce;\n  var integrate = factory.integrate;\n  var createBody = pos => new Body(pos);\n\n  var random = __webpack_require__(/*! ngraph.random */ \"./node_modules/ngraph.random/index.js\").random(42);\n  var bodies = []; // Bodies in this simulation.\n  var springs = []; // Springs in this simulation.\n\n  var quadTree =  createQuadTree(settings, random);\n  var bounds = createBounds(bodies, settings, random);\n  var springForce = createSpringForce(settings, random);\n  var dragForce = createDragForce(settings);\n\n  var totalMovement = 0; // how much movement we made on last step\n  var forces = [];\n  var forceMap = new Map();\n  var iterationNumber = 0;\n \n  addForce('nbody', nbodyForce);\n  addForce('spring', updateSpringForce);\n\n  var publicApi = {\n    /**\n     * Array of bodies, registered with current simulator\n     *\n     * Note: To add new body, use addBody() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    bodies: bodies,\n  \n    quadTree: quadTree,\n\n    /**\n     * Array of springs, registered with current simulator\n     *\n     * Note: To add new spring, use addSpring() method. This property is only\n     * exposed for testing/performance purposes.\n     */\n    springs: springs,\n\n    /**\n     * Returns settings with which current simulator was initialized\n     */\n    settings: settings,\n\n    /**\n     * Adds a new force to simulation\n     */\n    addForce: addForce,\n    \n    /**\n     * Removes a force from the simulation.\n     */\n    removeForce: removeForce,\n\n    /**\n     * Returns a map of all registered forces.\n     */\n    getForces: getForces,\n\n    /**\n     * Performs one step of force simulation.\n     *\n     * @returns {boolean} true if system is considered stable; False otherwise.\n     */\n    step: function () {\n      for (var i = 0; i < forces.length; ++i) {\n        forces[i](iterationNumber);\n      }\n      var movement = integrate(bodies, settings.timeStep, settings.adaptiveTimeStepWeight);\n      iterationNumber += 1;\n      return movement;\n    },\n\n    /**\n     * Adds body to the system\n     *\n     * @param {ngraph.physics.primitives.Body} body physical body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBody: function (body) {\n      if (!body) {\n        throw new Error('Body is required');\n      }\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Adds body to the system at given position\n     *\n     * @param {Object} pos position of a body\n     *\n     * @returns {ngraph.physics.primitives.Body} added body\n     */\n    addBodyAt: function (pos) {\n      if (!pos) {\n        throw new Error('Body position is required');\n      }\n      var body = createBody(pos);\n      bodies.push(body);\n\n      return body;\n    },\n\n    /**\n     * Removes body from the system\n     *\n     * @param {ngraph.physics.primitives.Body} body to remove\n     *\n     * @returns {Boolean} true if body found and removed. falsy otherwise;\n     */\n    removeBody: function (body) {\n      if (!body) { return; }\n\n      var idx = bodies.indexOf(body);\n      if (idx < 0) { return; }\n\n      bodies.splice(idx, 1);\n      if (bodies.length === 0) {\n        bounds.reset();\n      }\n      return true;\n    },\n\n    /**\n     * Adds a spring to this simulation.\n     *\n     * @returns {Object} - a handle for a spring. If you want to later remove\n     * spring pass it to removeSpring() method.\n     */\n    addSpring: function (body1, body2, springLength, springCoefficient) {\n      if (!body1 || !body2) {\n        throw new Error('Cannot add null spring to force simulator');\n      }\n\n      if (typeof springLength !== 'number') {\n        springLength = -1; // assume global configuration\n      }\n\n      var spring = new Spring(body1, body2, springLength, springCoefficient >= 0 ? springCoefficient : -1);\n      springs.push(spring);\n\n      // TODO: could mark simulator as dirty.\n      return spring;\n    },\n\n    /**\n     * Returns amount of movement performed on last step() call\n     */\n    getTotalMovement: function () {\n      return totalMovement;\n    },\n\n    /**\n     * Removes spring from the system\n     *\n     * @param {Object} spring to remove. Spring is an object returned by addSpring\n     *\n     * @returns {Boolean} true if spring found and removed. falsy otherwise;\n     */\n    removeSpring: function (spring) {\n      if (!spring) { return; }\n      var idx = springs.indexOf(spring);\n      if (idx > -1) {\n        springs.splice(idx, 1);\n        return true;\n      }\n    },\n\n    getBestNewBodyPosition: function (neighbors) {\n      return bounds.getBestNewPosition(neighbors);\n    },\n\n    /**\n     * Returns bounding box which covers all bodies\n     */\n    getBBox: getBoundingBox, \n    getBoundingBox: getBoundingBox, \n\n    invalidateBBox: function () {\n      console.warn('invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call');\n    },\n\n    // TODO: Move the force specific stuff to force\n    gravity: function (value) {\n      if (value !== undefined) {\n        settings.gravity = value;\n        quadTree.options({gravity: value});\n        return this;\n      } else {\n        return settings.gravity;\n      }\n    },\n\n    theta: function (value) {\n      if (value !== undefined) {\n        settings.theta = value;\n        quadTree.options({theta: value});\n        return this;\n      } else {\n        return settings.theta;\n      }\n    },\n\n    /**\n     * Returns pseudo-random number generator instance.\n     */\n    random: random\n  };\n\n  // allow settings modification via public API:\n  expose(settings, publicApi);\n\n  eventify(publicApi);\n\n  return publicApi;\n\n  function getBoundingBox() {\n    bounds.update();\n    return bounds.box;\n  }\n\n  function addForce(forceName, forceFunction) {\n    if (forceMap.has(forceName)) throw new Error('Force ' + forceName + ' is already added');\n\n    forceMap.set(forceName, forceFunction);\n    forces.push(forceFunction);\n  }\n\n  function removeForce(forceName) {\n    var forceIndex = forces.indexOf(forceMap.get(forceName));\n    if (forceIndex < 0) return;\n    forces.splice(forceIndex, 1);\n    forceMap.delete(forceName);\n  }\n\n  function getForces() {\n    // TODO: Should I trust them or clone the forces?\n    return forceMap;\n  }\n\n  function nbodyForce(/* iterationUmber */) {\n    if (bodies.length === 0) return;\n\n    quadTree.insertBodies(bodies);\n    var i = bodies.length;\n    while (i--) {\n      var body = bodies[i];\n      if (!body.isPinned) {\n        body.reset();\n        quadTree.updateBodyForce(body);\n        dragForce.update(body);\n      }\n    }\n  }\n\n  function updateSpringForce() {\n    var i = springs.length;\n    while (i--) {\n      springForce.update(springs[i]);\n    }\n  }\n\n}\n\nfunction expose(settings, target) {\n  for (var key in settings) {\n    augment(settings, target, key);\n  }\n}\n\nfunction augment(source, target, key) {\n  if (!source.hasOwnProperty(key)) return;\n  if (typeof target[key] === 'function') {\n    // this accessor is already defined. Ignore it\n    return;\n  }\n  var sourceIsNumber = Number.isFinite(source[key]);\n\n  if (sourceIsNumber) {\n    target[key] = function (value) {\n      if (value !== undefined) {\n        if (!Number.isFinite(value)) throw new Error('Value of ' + key + ' should be a valid number.');\n        source[key] = value;\n        return target;\n      }\n      return source[key];\n    };\n  } else {\n    target[key] = function (value) {\n      if (value !== undefined) {\n        source[key] = value;\n        return target;\n      }\n      return source[key];\n    };\n  }\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/createPhysicsSimulator.js?");

/***/ }),

/***/ "./lib/spring.js":
/*!***********************!*\
  !*** ./lib/spring.js ***!
  \***********************/
/***/ ((module) => {

eval("module.exports = Spring;\n\n/**\n * Represents a physical spring. Spring connects two bodies, has rest length\n * stiffness coefficient and optional weight\n */\nfunction Spring(fromBody, toBody, length, springCoefficient) {\n    this.from = fromBody;\n    this.to = toBody;\n    this.length = length;\n    this.coefficient = springCoefficient;\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./lib/spring.js?");

/***/ }),

/***/ "./node_modules/ngraph.events/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.events/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = function eventify(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./node_modules/ngraph.events/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.merge/index.js":
/*!********************************************!*\
  !*** ./node_modules/ngraph.merge/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("module.exports = merge;\n\n/**\n * Augments `target` with properties in `options`. Does not override\n * target's properties if they are defined and matches expected type in \n * options\n *\n * @returns {Object} merged object\n */\nfunction merge(target, options) {\n  var key;\n  if (!target) { target = {}; }\n  if (options) {\n    for (key in options) {\n      if (options.hasOwnProperty(key)) {\n        var targetHasIt = target.hasOwnProperty(key),\n            optionsValueType = typeof options[key],\n            shouldReplace = !targetHasIt || (typeof target[key] !== optionsValueType);\n\n        if (shouldReplace) {\n          target[key] = options[key];\n        } else if (optionsValueType === 'object') {\n          // go deep, don't care about loops here, we are simple API!:\n          target[key] = merge(target[key], options[key]);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n\n//# sourceURL=webpack://ngraph.forcelayout/./node_modules/ngraph.merge/index.js?");

/***/ }),

/***/ "./node_modules/ngraph.random/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ngraph.random/index.js ***!
  \*********************************************/
/***/ ((module) => {

eval("module.exports = random;\n\n// TODO: Deprecate?\nmodule.exports.random = random,\nmodule.exports.randomIterator = randomIterator\n\n/**\n * Creates seeded PRNG with two methods:\n *   next() and nextDouble()\n */\nfunction random(inputSeed) {\n  var seed = typeof inputSeed === 'number' ? inputSeed : (+new Date());\n  return new Generator(seed)\n}\n\nfunction Generator(seed) {\n  this.seed = seed;\n}\n\n/**\n  * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n  *\n  * @param maxValue Number REQUIRED. Omitting this number will result in NaN values from PRNG.\n  */\nGenerator.prototype.next = next;\n\n/**\n  * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n  * This function is the same as Math.random() (except that it could be seeded)\n  */\nGenerator.prototype.nextDouble = nextDouble;\n\n/**\n * Returns a random real number uniformly in [0, 1)\n */\nGenerator.prototype.uniform = nextDouble;\n\nGenerator.prototype.gaussian = gaussian;\n\nfunction gaussian() {\n  // use the polar form of the Box-Muller transform\n  // based on https://introcs.cs.princeton.edu/java/23recursion/StdRandom.java\n  var r, x, y;\n  do {\n    x = this.nextDouble() * 2 - 1;\n    y = this.nextDouble() * 2 - 1;\n    r = x * x + y * y;\n  } while (r >= 1 || r === 0);\n\n  return x * Math.sqrt(-2 * Math.log(r)/r);\n}\n\nfunction nextDouble() {\n  var seed = this.seed;\n  // Robert Jenkins' 32 bit integer hash function.\n  seed = ((seed + 0x7ed55d16) + (seed << 12)) & 0xffffffff;\n  seed = ((seed ^ 0xc761c23c) ^ (seed >>> 19)) & 0xffffffff;\n  seed = ((seed + 0x165667b1) + (seed << 5)) & 0xffffffff;\n  seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff;\n  seed = ((seed + 0xfd7046c5) + (seed << 3)) & 0xffffffff;\n  seed = ((seed ^ 0xb55a4f09) ^ (seed >>> 16)) & 0xffffffff;\n  this.seed = seed;\n  return (seed & 0xfffffff) / 0x10000000;\n}\n\nfunction next(maxValue) {\n  return Math.floor(this.nextDouble() * maxValue);\n}\n\n/*\n * Creates iterator over array, which returns items of array in random order\n * Time complexity is guaranteed to be O(n);\n */\nfunction randomIterator(array, customRandom) {\n  var localRandom = customRandom || random();\n  if (typeof localRandom.next !== 'function') {\n    throw new Error('customRandom does not match expected API: next() function is missing');\n  }\n\n  return {\n    forEach: forEach,\n\n    /**\n     * Shuffles array randomly, in place.\n     */\n    shuffle: shuffle\n  };\n\n  function shuffle() {\n    var i, j, t;\n    for (i = array.length - 1; i > 0; --i) {\n      j = localRandom.next(i + 1); // i inclusive\n      t = array[j];\n      array[j] = array[i];\n      array[i] = t;\n    }\n\n    return array;\n  }\n\n  function forEach(callback) {\n    var i, j, t;\n    for (i = array.length - 1; i > 0; --i) {\n      j = localRandom.next(i + 1); // i inclusive\n      t = array[j];\n      array[j] = array[i];\n      array[i] = t;\n\n      callback(t);\n    }\n\n    if (array.length) {\n      callback(array[0]);\n    }\n  }\n}\n\n//# sourceURL=webpack://ngraph.forcelayout/./node_modules/ngraph.random/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./index.js");
/******/ })()
;